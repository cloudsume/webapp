export class ULID {
  constructor(v: Uint8Array);
  constructor(v: string);
  constructor(v: Uint8Array | string) {
    if (typeof v === 'string') {
      this.data = parse(v);
    } else if (v.length !== 16) {
      throw new Error('The value must be 16 bytes exactly.');
    } else {
      this.data = v;
    }
  }

  get time(): Date {
    return new Date(this.timestamp);
  }

  get timestamp(): number {
    const timestamp = new Uint8Array(8);

    timestamp.set(this.data.slice(0, 6), 2);

    return new Number(new DataView(timestamp.buffer).getBigInt64(0)).valueOf();
  }

  equals(other: ULID): boolean {
    for (let i = 0; i < 16; i++) {
      if (this.data[i] !== other.data[i]) {
        return false;
      }
    }

    return true;
  }

  toString(): string {
    let r = '';

    // timestamp
    r += base32[this.data[0] >> 5];                                 // |00[111|11111][11111111][11111111][11111111][11111111][11111111]
    r += base32[this.data[0] & 0x1f];                               // 00[111|11111|][11111111][11111111][11111111][11111111][11111111]
    r += base32[this.data[1] >> 3];                                 // 00[11111111][|11111|111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[1] & 0x7) << 2) | (this.data[2] >> 6)]; // 00[11111111][11111|111][11|111111][11111111][11111111][11111111]
    r += base32[(this.data[2] >> 1) & 0x1f];                        // 00[11111111][11111111][11|11111|1][11111111][11111111][11111111]
    r += base32[((this.data[2] & 0x1) << 4) | (this.data[3] >> 4)]; // 00[11111111][11111111][1111111|1][1111|1111][11111111][11111111]
    r += base32[((this.data[3] & 0xf) << 1) | (this.data[4] >> 7)]; // 00[11111111][11111111][11111111][1111|1111][1|1111111][11111111]
    r += base32[(this.data[4] >> 2) & 0x1f];                        // 00[11111111][11111111][11111111][11111111][1|11111|11][11111111]
    r += base32[((this.data[4] & 0x3) << 3) | (this.data[5] >> 5)]; // 00[11111111][11111111][11111111][11111111][111111|11][111|11111]
    r += base32[this.data[5] & 0x1f];                               // 00[11111111][11111111][11111111][11111111][11111111][111|11111|]

    // randomness
    r += base32[(this.data[6] >> 3) & 0x1f];                          // [|11111|111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[6] & 0x7) << 2) | (this.data[7] >> 6)];   // [11111|111][11|111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[(this.data[7] >> 1) & 0x1f];                          // [11111111][11|11111|1][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[7] & 0x1) << 4) | (this.data[8] >> 4)];   // [11111111][1111111|1][1111|1111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[8] & 0xf) << 1) | (this.data[9] >> 7)];   // [11111111][11111111][1111|1111][1|1111111][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[(this.data[9] >> 2) & 0x1f];                          // [11111111][11111111][11111111][1|11111|11][11111111][11111111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[9] & 0x3) << 3) | (this.data[10] >> 5)];  // [11111111][11111111][11111111][111111|11][111|11111][11111111][11111111][11111111][11111111][11111111]
    r += base32[this.data[10] & 0x1f];                                // [11111111][11111111][11111111][11111111][111|11111|][11111111][11111111][11111111][11111111][11111111]

    r += base32[(this.data[11] >> 3) & 0x1f];                         // [11111111][11111111][11111111][11111111][11111111][|11111|111][11111111][11111111][11111111][11111111]
    r += base32[((this.data[11] & 0x7) << 2) | (this.data[12] >> 6)]; // [11111111][11111111][11111111][11111111][11111111][11111|111][11|111111][11111111][11111111][11111111]
    r += base32[(this.data[12] >> 1) & 0x1f];                         // [11111111][11111111][11111111][11111111][11111111][11111111][11|11111|1][11111111][11111111][11111111]
    r += base32[((this.data[12] & 0x1) << 4) | (this.data[13] >> 4)]; // [11111111][11111111][11111111][11111111][11111111][11111111][1111111|1][1111|1111][11111111][11111111]
    r += base32[((this.data[13] & 0xf) << 1) | (this.data[14] >> 7)]; // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][1111|1111][1|1111111][11111111]
    r += base32[(this.data[14] >> 2) & 0x1f];                         // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][1|11111|11][11111111]
    r += base32[((this.data[14] & 0x3) << 3) | (this.data[15] >> 5)]; // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][111111|11][111|11111]
    r += base32[this.data[15] & 0x1f];                                // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][111|11111|]

    return r;
  }

  private readonly data: Uint8Array;
}

export const Empty = new ULID(new Uint8Array(16));

const base32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
const values = new Map<number, number>(generateValues());

function parse(s: string): Uint8Array {
  if (s.length != 26) {
    throw new TypeError();
  }

  const value = (i: number): number => {
    const v = values.get(s.codePointAt(i)!);

    if (v === undefined) {
      throw new TypeError();
    } else {
      return v;
    }
  }

  // check first character
  let c = value(0);

  if (c > 7) {
    // the first character can contains only 3 bits
    throw new TypeError();
  }

  // decode remaining
  const r = new Uint8Array(16);

  r[0x0] = (c << 5) | value(1);                                         // |00[111|11111|][11111111][11111111][11111111][11111111][11111111]
  r[0x1] = (value(2) << 3) | ((c = value(3)) >> 2);                     // 00[11111111][|11111|111][11|111111][11111111][11111111][11111111]
  r[0x2] = ((c << 6) & 0xff) | (value(4) << 1) | ((c = value(5)) >> 4); // 00[11111111][11111|111][11|11111|1][1111|1111][11111111][11111111]
  r[0x3] = ((c << 4) & 0xff) | ((c = value(6)) >> 1);                   // 00[11111111][11111111][1111111|1][1111|1111][1|1111111][11111111]
  r[0x4] = ((c << 7) & 0xff) | (value(7) << 2) | ((c = value(8)) >> 3); // 00[11111111][11111111][11111111][1111|1111][1|11111|11][111|11111]
  r[0x5] = ((c << 5) & 0xff) | value(9);                                // 00[11111111][11111111][11111111][11111111][111111|11][111|11111|]

  r[0x6] = (value(10) << 3) | ((c = value(11)) >> 2);                     // [|11111|111][11|111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
  r[0x7] = ((c << 6) & 0xff) | (value(12) << 1) | ((c = value(13)) >> 4); // [11111|111][11|11111|1][1111|1111][11111111][11111111][11111111][11111111][11111111][11111111][11111111]
  r[0x8] = ((c << 4) & 0xff) | ((c = value(14)) >> 1);                    // [11111111][1111111|1][1111|1111][1|1111111][11111111][11111111][11111111][11111111][11111111][11111111]
  r[0x9] = ((c << 7) & 0xff) | (value(15) << 2) | ((c = value(16)) >> 3); // [11111111][11111111][1111|1111][1|11111|11][111|11111][11111111][11111111][11111111][11111111][11111111]
  r[0xa] = ((c << 5) & 0xff) | value(17);                                 // [11111111][11111111][11111111][111111|11][111|11111|][11111111][11111111][11111111][11111111][11111111]
  r[0xb] = ((value(18) << 3) | ((c = value(19)) >> 2));                   // [11111111][11111111][11111111][11111111][11111111][|11111|111][11|111111][11111111][11111111][11111111]
  r[0xc] = ((c << 6) & 0xff) | (value(20) << 1) | ((c = value(21)) >> 4); // [11111111][11111111][11111111][11111111][11111111][11111|111][11|11111|1][1111|1111][11111111][11111111]
  r[0xd] = ((c << 4) & 0xff) | ((c = value(22)) >> 1);                    // [11111111][11111111][11111111][11111111][11111111][11111111][1111111|1][1111|1111][1|1111111][11111111]
  r[0xe] = ((c << 7) & 0xff) | (value(23) << 2) | ((c = value(24)) >> 3); // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][1111|1111][1|11111|11][111|11111]
  r[0xf] = ((c << 5) & 0xff) | value(25);                                 // [11111111][11111111][11111111][11111111][11111111][11111111][11111111][11111111][111111|11][111|11111|]

  return r;
}

function* generateValues(): Generator<[number, number]> {
  // all
  for (let i = 0, v = 0; i < base32.length; i++) {
    yield [base32[i].codePointAt(0)!, v++];
  }

  // a - z
  for (let i = 10, v = 10; i < base32.length; i++) {
    yield [base32[i].toLowerCase().codePointAt(0)!, v++];
  }

  yield [0x49, 1]; // I
  yield [0x4c, 1]; // L
  yield [0x4f, 0]; // O
  yield [0x69, 1]; // i
  yield [0x6c, 1]; // l
  yield [0x6f, 0]; // o
}
